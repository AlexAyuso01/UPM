################################################################################
La especificacion de una funcion que recibe un parametro es de la forma:
  funcion(parametros){
    lo que haga la funcion
  }
La especificacion de una funcion dentro de una subrutina no limita su uso dentro
de otras
Si en la especificacion de una funcion esta viene marcada con * se le llama a
la vez que se especifica:
  funcion * (parametros){
    lo que haga la funcion
  }
Dato a memoria : Dato -> [memoria]
Pseudolenguaje no tipado
Comentarios empiezan por ##, string envuelto por ## comentario ## no forma parte
del codigo
################################################################################

1.1. ESCCAR(buffer, caracter)
  SeleccionBuffer(){
    DirB = direccion a listado donde se inicializan los buferes
    space = nro instrucciones necesarias para calcular salto * cuanto ocupa cada
    branch a salto = dirB + space
  }
  CargaBuffer(){
    Carga de punteros de inserción/extraccion y dir buffer
  }
  sigPos = Tamaño buffer + Dir buffer + 1
  if(ptroExtrBuff != ptroInsercionBuf){
    caracter -> [sigPos]
    D0 = 0 ## exito
  }
  else {
    #fin buffer
    PE = ptro inicio bufer
    D0 = FFFFFFFF ## lleno
  }
  return D0
  fin(RTS)

  1.2. Leecar(Buffer)
  SeleccionBuffer()
  CargaBuffer()
  if(ptroExtrBuff !=ptroInsercionBuf){
    actualizar ptro insercion
    [ptroExtrBuf]->= D0 ## exito
    ptroExtrBuf++
  }
  else {
    PE = ptro inicio bufer
  }
  return D0
  fin(RTS)


1.3. Init
  Inicilizar lineas A y B con parámetros
  {
    Dar acceso a reg. modo 1
    8 bits por caracter
    Desactivar el eco
    Modo full duplex
    Velocidad = 38400 bps tx y rx
  }
  Inicializaciones globales
  {
    Conjunto de veloc. 1
    0x40 -> registro de vectores de interrupcion
    Activar bits 1 y 5 para interr. RX
    Actualiza copia del IMR
    RTI -> primer vector de interrupcion ($100)
  }
  Inicializacion de buferes transmision y recepcion
  {
    ptroExtrBuf
    ptroInsercionBuf
    ptroBuffer
    bit interrupcion buffer
  }
  Inicializacion de los contadores a cero y reseteo de A0
  fin(RTS)

1.4. Print (buffer, descriptor, tamaño)
  meterPila(listaRegitros, RegPtroMarco){
    crearMarcodePila(|listaRegistros| * 4, RegptroMarco)
    pushRegistros
    Parametros(buffer, descriptor, tamaño) -> registros
  }
  elegirLineaX(descriptor){
    if(descriptor==0){
      D0 = 2
    }
    if(descriptor==1){
      D0 = 3
    }
    else{
      fin(RTS)
      }
    }
  while(contador!=tamaño && D0!=FFFFFFFF)
    linea = elegirLineaX(descriptor)
    ESCCAR(D0, buffer++)
    contador++
  }
  if (contador!=0){
    habilitarTX(D0){
      if (D0==0) bit num0=1 de IMRduplicado
      if (D0==1) bit num4=1 de IMRduplicado
      actualizar IMR
      }
  }
  ##contador == 0? -> no se activan interrupciones = branch fin Print
  D0 = contador
  sacarPila(){
      popRegistros
      destruccionMarcoPila(RegptroMarco)
  }
  return D0
  fin(RTS)

1.5. Scan
  meterPila(listaRegitros,RegPtroMarco)
  elegirLineaXScan(descriptor){
      if(descriptor==0){
        D0 = 1
      }
      if(descriptor==1){
        D0 = 1
      }
      else {D0=FFFFFFFF}

  while(tamaño > 0 && contador!=tamaño) {
    elegirLineaXScan(descriptor)
    LEECAR(buffer)
    if(d0 != FFFFFFFF){
      ptro buffer ++
      contador ++
  }
  else {
    d0=0
    fin(RTS)
    }
  }
  D0 = contador
  sacarPila()
  return D0
  fin(RTS)

1.6. RTI
  meterPila()
  interr = AND.B(IMRduplicado, ISR)
  BTST(interr)(){
    realiza btst en interr y devuelve bitX, indica si es RX o TX
  }
        if ( bitX == 5 || bitX == 1){
         buffer = elegirLineaXScan(descriptor)
         if (buffer==0){ RBX = RBA } ##direccion buffer recepcion de linea A
         else { RBX = RBB } ##direccion buffer recepcion de linea B)
         ESCCAR(buffer, RBX)
        }
        if ( bitX == 5 || bitX == 1){
          linea = elegirLineaX(descriptor)
          if (linea==0){ buffer = 2 } ##direccion buffer recepcion de linea A)
          else { buffer = 4 } ##direccion buffer recepcion de linea B)
          result = LEECAR(buffer)
          if(result==-1 ##$FFFFFFFF##){
            desactivarTX(D0){
              if (D0==0) { bit num0=0 de IMRduplicado }
              if (D0==1) { bit num4=0 de IMRduplicado }
              actualizar IMR
            }
            else{
              transimision de caracter leido si existe por TBA || TBB
            }
        }
      }
  }

    sacarPila
    fin(RTE)
